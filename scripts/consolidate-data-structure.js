#!/usr/bin/env node

/**
 * Data Structure Consolidation Script
 * 
 * Automatically fixes common data mapping issues and consolidates
 * inconsistent field access patterns in the codebase
 */

const fs = require('fs');
const path = require('path');

class DataStructureConsolidator {
  constructor() {
    this.fixes = [];
    this.backups = [];
  }

  async consolidate() {
    console.log('üîß Starting data structure consolidation...\n');

    // Step 1: Create backups
    this.createBackups();

    // Step 2: Fix field naming inconsistencies  
    await this.fixFieldNaming();

    // Step 3: Standardize enhanced data access
    await this.standardizeEnhancedDataAccess();

    // Step 4: Add missing data mappings
    await this.addMissingDataMappings();

    // Step 5: Add Pa11y score calculation
    await this.addPa11yScoreCalculation();

    // Step 6: Generate summary
    this.generateSummary();
  }

  createBackups() {
    console.log('üíæ Creating backups of files to be modified...');

    const filesToBackup = [
      'src/generators/html-generator.ts',
      'src/reports/html-report.ts'
    ];

    filesToBackup.forEach(file => {
      if (fs.existsSync(file)) {
        const backupPath = `${file}.backup.${Date.now()}`;\n        fs.copyFileSync(file, backupPath);\n        this.backups.push({ original: file, backup: backupPath });\n        console.log(`   ‚úÖ Backed up ${file} -> ${path.basename(backupPath)}`);\n      }\n    });\n  }\n\n  async fixFieldNaming() {\n    console.log('\\nüè∑Ô∏è Fixing field naming inconsistencies...');\n\n    const generatorPath = 'src/generators/html-generator.ts';\n    if (!fs.existsSync(generatorPath)) {\n      console.log('   ‚ö†Ô∏è html-generator.ts not found, skipping...');\n      return;\n    }\n\n    let content = fs.readFileSync(generatorPath, 'utf-8');\n    let changes = 0;\n\n    // Fix enhancedSeo -> enhancedSEO inconsistency\n    const seoReplacements = [\n      // In filter conditions\n      {\n        from: /page\\.enhancedSeo(?!\\w)/g,\n        to: 'page.enhancedSEO',\n        description: 'Standardize SEO field access'\n      },\n      // In method parameters\n      {\n        from: /enhancedSeo(?=\\s*[\\)\\.])/g,\n        to: 'enhancedSEO',\n        description: 'Standardize SEO parameter names'\n      }\n    ];\n\n    seoReplacements.forEach(replacement => {\n      const matches = content.match(replacement.from);\n      if (matches) {\n        content = content.replace(replacement.from, replacement.to);\n        changes += matches.length;\n        console.log(`   ‚úÖ ${replacement.description}: ${matches.length} replacements`);\n      }\n    });\n\n    if (changes > 0) {\n      fs.writeFileSync(generatorPath, content);\n      this.fixes.push(`Fixed ${changes} field naming inconsistencies`);\n    }\n  }\n\n  async standardizeEnhancedDataAccess() {\n    console.log('\\nüîó Standardizing enhanced data access patterns...');\n\n    const generatorPath = 'src/generators/html-generator.ts';\n    let content = fs.readFileSync(generatorPath, 'utf-8');\n\n    // Add helper method for consistent data access\n    const helperMethod = `\n  /**\n   * Helper method to safely access enhanced data with fallbacks\n   */\n  private getEnhancedData(page: any, field: string) {\n    // Handle different field naming conventions\n    const fieldMappings: { [key: string]: string[] } = {\n      'performance': ['enhancedPerformance'],\n      'seo': ['enhancedSEO', 'enhancedSeo'],\n      'contentWeight': ['contentWeight'],\n      'mobile': ['mobileFriendliness', 'enhancedPerformance.mobileFriendliness']\n    };\n\n    const possibleFields = fieldMappings[field] || [field];\n    \n    for (const fieldName of possibleFields) {\n      if (fieldName.includes('.')) {\n        // Handle nested field access\n        const [parent, child] = fieldName.split('.');\n        if (page[parent] && page[parent][child]) {\n          return page[parent][child];\n        }\n      } else {\n        if (page[fieldName]) {\n          return page[fieldName];\n        }\n      }\n    }\n    \n    return null;\n  }\n`;\n\n    // Add helper method if not already present\n    if (!content.includes('getEnhancedData')) {\n      // Insert before the last closing brace\n      const lastBraceIndex = content.lastIndexOf('}');\n      content = content.slice(0, lastBraceIndex) + helperMethod + '\\n}';\n      \n      console.log('   ‚úÖ Added enhanced data access helper method');\n      this.fixes.push('Added enhanced data access helper method');\n    }\n\n    fs.writeFileSync(generatorPath, content);\n  }\n\n  async addMissingDataMappings() {\n    console.log('\\nüó∫Ô∏è Adding missing data mappings...');\n\n    const generatorPath = 'src/generators/html-generator.ts';\n    let content = fs.readFileSync(generatorPath, 'utf-8');\n\n    // Fix mobile-friendliness section to use correct data access\n    const mobileMethodFix = `  generateMobileFriendlinessSection(data: any): string {\n    return \\`<section id=\"mobile-friendliness\">\n      <div class=\"table-wrapper\">\n        <table class=\"data-table\">\n        <thead><tr><th>Page</th><th>Mobile Score</th><th>Issues</th></tr></thead>\n        <tbody>\n          \\${data.pages.map((page: any) => {\n            // Use helper method for consistent data access\n            const mobileData = this.getEnhancedData(page, 'mobile') || page.mobileFriendliness;\n            const mobileScore = mobileData?.score ?? 'N/A';\n            const mobileIssues = mobileData?.issues?.length ?? 0;\n            const formattedScore = mobileScore !== 'N/A' && typeof mobileScore === 'number' ? \n              \\`\\${Math.round(mobileScore)}/100\\` : mobileScore;\n            \n            return \\`<tr>\n              <td>\\${page.url}</td>\n              <td>\\${formattedScore}</td>\n              <td>\\${mobileIssues}</td>\n            </tr>\\`;\n          }).join('')}\n        </tbody>\n        </table>\n      </div>\n    </section>\\`;\n  }`;\n\n    // Replace the mobile-friendliness method\n    const mobileMethodRegex = /generateMobileFriendlinessSection\\(data: any\\): string \\{[\\s\\S]*?\\n  \\}/;\n    if (mobileMethodRegex.test(content)) {\n      content = content.replace(mobileMethodRegex, mobileMethodFix);\n      console.log('   ‚úÖ Fixed mobile-friendliness data mapping');\n      this.fixes.push('Fixed mobile-friendliness data mapping');\n    }\n\n    fs.writeFileSync(generatorPath, content);\n  }\n\n  async addPa11yScoreCalculation() {\n    console.log('\\nüßÆ Adding Pa11y score calculation...');\n\n    const generatorPath = 'src/generators/html-generator.ts';\n    let content = fs.readFileSync(generatorPath, 'utf-8');\n\n    // Add Pa11y score calculation method\n    const pa11yCalculationMethod = `\n  /**\n   * Calculate Pa11y score based on errors and warnings\n   * Algorithm: Start at 100, deduct points for errors and warnings\n   */\n  private calculatePa11yScore(errors: number, warnings: number): number {\n    let score = 100;\n    \n    // Deduct 5 points per error (more severe)\n    score -= errors * 5;\n    \n    // Deduct 1 point per warning (less severe)\n    score -= warnings * 1;\n    \n    // Ensure score doesn't go below 0\n    return Math.max(0, score);\n  }\n`;\n\n    // Add calculation method if not present\n    if (!content.includes('calculatePa11yScore')) {\n      const lastBraceIndex = content.lastIndexOf('}');\n      content = content.slice(0, lastBraceIndex) + pa11yCalculationMethod + '\\n}';\n      \n      console.log('   ‚úÖ Added Pa11y score calculation method');\n      this.fixes.push('Added Pa11y score calculation method');\n    }\n\n    // Update accessibility section to use calculated Pa11y score\n    const accessibilityMethodRegex = /(generateAccessibilitySection\\(data: any\\): string \\{[\\s\\S]*?)const pa11yScore = page\\.issues\\?\\.pa11yScore \\?\\? page\\.pa11yScore \\?\\? 'N\\/A';([\\s\\S]*?const formattedScore = pa11yScore !== 'N\\/A' && typeof pa11yScore === 'number' \\?[\\s\\S]*?pa11yScore;)/;\n    \n    if (accessibilityMethodRegex.test(content)) {\n      const replacement = (match, before, after) => {\n        return before + \n          `// Calculate Pa11y score if not available\\n            const pa11yScore = page.issues?.pa11yScore ?? page.pa11yScore ?? this.calculatePa11yScore(page.errors || 0, page.warnings || 0);` +\n          after;\n      };\n      \n      content = content.replace(accessibilityMethodRegex, replacement);\n      console.log('   ‚úÖ Updated accessibility section to calculate Pa11y scores');\n      this.fixes.push('Updated accessibility section with Pa11y calculation');\n    }\n\n    fs.writeFileSync(generatorPath, content);\n  }\n\n  generateSummary() {\n    console.log('\\nüìã Consolidation Summary:');\n    console.log('='.repeat(50));\n    \n    if (this.fixes.length === 0) {\n      console.log('‚úÖ No consolidation needed - data structure is already consistent');\n    } else {\n      console.log(`‚úÖ Applied ${this.fixes.length} fixes:`);\n      this.fixes.forEach((fix, index) => {\n        console.log(`   ${index + 1}. ${fix}`);\n      });\n    }\n\n    console.log('\\nüíæ Backups created:');\n    this.backups.forEach(backup => {\n      console.log(`   ${backup.original} -> ${backup.backup}`);\n    });\n\n    console.log('\\nüîÑ Next steps:');\n    console.log('   1. Run: npm run build');\n    console.log('   2. Test: npm test');\n    console.log('   3. Run analysis: node scripts/analyze-data-structure.js');\n    console.log('   4. If satisfied, delete backup files');\n\n    console.log('\\n‚ö†Ô∏è To restore from backup:');\n    this.backups.forEach(backup => {\n      console.log(`   cp ${backup.backup} ${backup.original}`);\n    });\n\n    // Save consolidation log\n    const logData = {\n      timestamp: new Date().toISOString(),\n      fixes: this.fixes,\n      backups: this.backups,\n      success: this.fixes.length > 0\n    };\n\n    fs.writeFileSync('consolidation-log.json', JSON.stringify(logData, null, 2));\n    console.log('\\nüìÅ Log saved to: consolidation-log.json');\n  }\n}\n\n// Enhanced Pa11y Score Algorithm Documentation\nconst PA11Y_SCORE_DOCS = `\n/**\n * Pa11y Score Calculation Algorithm\n * \n * The Pa11y score represents the accessibility quality of a page on a scale of 0-100.\n * \n * Algorithm:\n * - Start with a perfect score of 100\n * - Deduct 5 points for each accessibility error (critical issues)\n * - Deduct 1 point for each accessibility warning (minor issues)\n * - Minimum score is 0 (never goes negative)\n * \n * Score Interpretation:\n * - 90-100: Excellent accessibility\n * - 75-89:  Good accessibility\n * - 50-74:  Fair accessibility (needs improvement)\n * - 0-49:   Poor accessibility (significant issues)\n * \n * This provides a quick visual indicator of page accessibility health\n * while giving more weight to critical errors than warnings.\n */\n`;\n\n// Run consolidation if called directly\nif (require.main === module) {\n  const consolidator = new DataStructureConsolidator();\n  consolidator.consolidate().catch(console.error);\n}\n\nmodule.exports = DataStructureConsolidator;
